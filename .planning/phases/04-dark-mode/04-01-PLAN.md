---
phase: 04-dark-mode
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/styles/global.css
  - src/components/ThemeToggle.astro
  - src/layouts/Base.astro
autonomous: false
requirements: [DARK-01, DARK-02, DARK-03, DARK-04, DARK-05]

must_haves:
  truths:
    - "User can click a toggle button to switch between light and dark themes"
    - "A first-time visitor with OS dark mode sees the dark theme without white flash"
    - "User switches to dark mode, closes browser, reopens page — dark mode persists"
    - "All text in dark mode passes WCAG AA contrast (4.5:1 body, 3:1 large text)"
  artifacts:
    - path: "src/styles/global.css"
      provides: "Dark theme CSS variable overrides"
      contains: "[data-theme=\"dark\"]"
    - path: "src/components/ThemeToggle.astro"
      provides: "Theme toggle button with sun/moon icon"
      contains: "theme-toggle"
    - path: "src/layouts/Base.astro"
      provides: "Blocking head script for FOUC prevention, ThemeToggle integration"
      contains: "localStorage.getItem('theme')"
  key_links:
    - from: "src/layouts/Base.astro"
      to: "src/styles/global.css"
      via: "head script sets data-theme attribute which activates CSS variable overrides"
      pattern: "data-theme"
    - from: "src/components/ThemeToggle.astro"
      to: "src/layouts/Base.astro"
      via: "component imported and rendered in layout"
      pattern: "ThemeToggle"
    - from: "src/components/ThemeToggle.astro"
      to: "localStorage"
      via: "click handler persists theme choice"
      pattern: "localStorage.setItem.*theme"
---

<objective>
Implement dark mode with a toggle button, system preference detection, localStorage persistence, FOUC prevention, and WCAG AA compliant dark palette.

Purpose: Users can switch between light and dark themes. The site respects their OS preference on first visit, remembers their choice, and never flashes the wrong theme on load.
Output: Dark mode fully functional on both IT (/) and EN (/en/) pages via shared Base.astro layout.
</objective>

<execution_context>
@/home/toto/.claude/get-shit-done/workflows/execute-plan.md
@/home/toto/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-dark-mode/04-RESEARCH.md
@.planning/phases/03-foundation-i18n-content/03-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add dark theme CSS variables and FOUC-preventing head script</name>
  <files>src/styles/global.css, src/layouts/Base.astro</files>
  <action>
**global.css** — Add `[data-theme="dark"]` selector block after the `:root` block with these WCAG AA verified dark palette values:

```css
/* Dark theme override — all pairs verified >= WCAG AA */
[data-theme="dark"] {
  --color-bg: #121212;
  --color-text: #e0e0e0;
  --color-text-secondary: #a0a0a0;
  --color-link: #6db3f2;
  --color-link-hover: #90caf9;
  --color-border: #333333;
}
```

Contrast ratios (verified in research):
- #e0e0e0 on #121212 = ~14.5:1 (body text, PASS)
- #a0a0a0 on #121212 = ~7.5:1 (secondary text, PASS)
- #6db3f2 on #121212 = ~6.8:1 (links, PASS)
- #90caf9 on #121212 = ~9.1:1 (link hover, PASS)

**Base.astro** — Add two things in `<head>`, placed after the viewport meta and before `<title>`:

1. `<meta name="color-scheme" content="light dark" />` — tells browser the page supports both schemes
2. Blocking `is:inline` script that:
   - Reads `localStorage.getItem('theme')` (wrapped in try/catch for private browsing)
   - Falls back to `window.matchMedia('(prefers-color-scheme: dark)').matches`
   - Defaults to 'light' if neither available
   - Sets `document.documentElement.setAttribute('data-theme', theme)`
   - Sets `document.documentElement.style.colorScheme = theme`
   - Persists initial detection to localStorage (try/catch wrapped)

Use the exact pattern from research:
```html
<meta name="color-scheme" content="light dark" />
<script is:inline>
  (function() {
    try { var stored = localStorage.getItem('theme'); }
    catch(e) { var stored = null; }
    var prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
    var theme = stored || (prefersDark ? 'dark' : 'light');
    document.documentElement.setAttribute('data-theme', theme);
    document.documentElement.style.colorScheme = theme;
    try { if (!stored) localStorage.setItem('theme', theme); } catch(e) {}
  })();
</script>
```

CRITICAL: The script MUST use `is:inline`. Without it, Astro bundles/defers the script as an ES module, causing a flash of wrong theme (FOUC). The `is:inline` directive inlines it directly into HTML for synchronous execution before paint.

Do NOT add any CSS transitions on color properties globally — this would cause a visible fade on every page load. Theme changes via the toggle will be instant (acceptable for a two-state toggle).
  </action>
  <verify>
1. Run `npm run build` — build succeeds with no errors
2. Check `dist/index.html` contains the inline script (not a deferred module reference)
3. Check `dist/index.html` contains `<meta name="color-scheme"`
4. Grep global.css for `[data-theme="dark"]` — dark variables block exists
  </verify>
  <done>
- global.css has [data-theme="dark"] block with 6 color variable overrides
- Base.astro has color-scheme meta tag and is:inline blocking script in head
- Build output contains inline script (not deferred), confirming FOUC prevention
  </done>
</task>

<task type="auto">
  <name>Task 2: Create ThemeToggle component and integrate in Base layout</name>
  <files>src/components/ThemeToggle.astro, src/layouts/Base.astro</files>
  <action>
**ThemeToggle.astro** — Create new component at `src/components/ThemeToggle.astro`:

1. Render a `<button>` with `id="theme-toggle"`, `type="button"`, `aria-label="Toggle dark mode"`
2. Inside the button, include two inline SVGs:
   - Sun icon (`.icon-sun`): circle + 8 ray lines, stroke="currentColor", aria-hidden="true"
   - Moon icon (`.icon-moon`): crescent path, stroke="currentColor", aria-hidden="true"
   - Both SVGs: width="20" height="20" viewBox="0 0 24 24" fill="none" stroke-width="2"
3. Scoped `<style>` block:
   - Button: `background: none; border: none; cursor: pointer; padding: 0.5rem; color: var(--color-text); display: flex; align-items: center; position: fixed; top: 1rem; right: 1rem; z-index: 1000;`
   - Default (light mode): `.icon-moon { display: none; }` `.icon-sun { display: block; }`
   - Dark mode: `:global([data-theme="dark"]) .icon-sun { display: none; }` `:global([data-theme="dark"]) .icon-moon { display: block; }`
4. `<script is:inline>` click handler:
   - Gets `document.documentElement`
   - Reads current `data-theme` attribute
   - Toggles to opposite ('dark' ↔ 'light')
   - Sets `data-theme` attribute on `<html>`
   - Sets `colorScheme` style on `<html>`
   - Calls `localStorage.setItem('theme', next)`

Use the exact pattern from research for the click handler:
```javascript
document.getElementById('theme-toggle')?.addEventListener('click', function() {
  var html = document.documentElement;
  var current = html.getAttribute('data-theme');
  var next = current === 'dark' ? 'light' : 'dark';
  html.setAttribute('data-theme', next);
  html.style.colorScheme = next;
  localStorage.setItem('theme', next);
});
```

**Base.astro** — Add ThemeToggle to layout:

1. Import: `import ThemeToggle from '../components/ThemeToggle.astro';`
2. Place `<ThemeToggle />` as the first child of `<body>`, before `<slot />`

The fixed-position styling on the button means placement in DOM doesn't affect visual layout. Placing it first in body ensures it's available early.

IMPORTANT: The `is:inline` on the toggle script is required because the button's event listener must attach synchronously. If Astro bundles it as a module, the listener may miss early clicks.
  </action>
  <verify>
1. Run `npm run build` — build succeeds
2. Check `dist/index.html` contains `id="theme-toggle"` button
3. Check `dist/index.html` contains both SVG icons (sun and moon)
4. Check `dist/en/index.html` also contains the toggle (inherits from Base.astro)
5. Grep ThemeToggle.astro for `is:inline` — present
6. Grep ThemeToggle.astro for `aria-label` — accessibility label present
  </verify>
  <done>
- ThemeToggle.astro component exists with button, sun/moon SVGs, scoped styles, and inline click handler
- Base.astro imports and renders ThemeToggle before slot
- Toggle button appears on both IT and EN pages (via shared layout)
- Button has aria-label for accessibility
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: Verify dark mode end-to-end</name>
  <files>src/styles/global.css, src/components/ThemeToggle.astro, src/layouts/Base.astro</files>
  <action>
Human verification of the complete dark mode implementation: CSS dark variables, FOUC-preventing head script, and ThemeToggle component integrated in Base.astro layout. Works on both IT (/) and EN (/en/) pages.

Start dev server with `npm run dev`, then verify all five requirements interactively.
  </action>
  <verify>
1. Start dev server: `npm run dev`
2. Open http://localhost:4321/ in browser

**Toggle functionality (DARK-01):**
3. Click the sun/moon icon in the top-right corner
4. Page should instantly switch to dark theme (dark background, light text)
5. Click again — page returns to light theme

**System preference (DARK-02):**
6. Set OS to dark mode (or use browser DevTools: Rendering > prefers-color-scheme: dark)
7. Open page in a new private/incognito window
8. Page should load in dark mode automatically (no toggle click needed)

**Persistence (DARK-03):**
9. Click toggle to switch to dark mode
10. Close the tab, reopen http://localhost:4321/
11. Page should still be in dark mode

**No flash (DARK-04):**
12. With dark mode stored in localStorage, hard refresh (Ctrl+Shift+R)
13. There should be NO white flash before dark theme appears

**WCAG contrast (DARK-05):**
14. In dark mode, visually verify: body text is readable, links are distinguishable, secondary text is legible

**Both locales:**
15. Navigate to http://localhost:4321/en/
16. Toggle should be present and functional on the English page too
17. Theme choice should persist across locale pages (both read same localStorage key)
  </verify>
  <done>User confirms all five dark mode requirements work correctly on both locale pages</done>
  <resume-signal>Type "approved" or describe any issues found</resume-signal>
</task>

</tasks>

<verification>
- `npm run build` succeeds with no errors
- Both `dist/index.html` and `dist/en/index.html` contain the inline theme script and toggle button
- No deferred script references for theme detection (must be inline)
- `[data-theme="dark"]` CSS block present in output stylesheet
- Toggle button has proper `aria-label` attribute
- All dark mode color pairs pass WCAG AA contrast ratios
</verification>

<success_criteria>
1. Toggle button visible on all pages, switches theme on click
2. First-time visitor with OS dark mode sees dark theme immediately (no flash)
3. Theme preference survives browser close/reopen via localStorage
4. All dark mode text passes WCAG AA contrast (4.5:1 body, 3:1 large)
5. Both IT and EN pages share identical dark mode behavior
</success_criteria>

<output>
After completion, create `.planning/phases/04-dark-mode/04-01-SUMMARY.md`
</output>
